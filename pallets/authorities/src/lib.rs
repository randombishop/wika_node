#![cfg_attr(not(feature = "std"), no_std)]



// Imports
// -------------------------------------------------

use sp_std::prelude::*;

use sp_std::{
	vec::Vec,
	convert::TryInto,
};

use frame_support::{
	ensure,
	decl_error, decl_event, decl_module, decl_storage
};

use frame_system::{
	ensure_root,
};

use wika_traits::AuthorityRegistry ;

use sp_runtime::SaturatedConversion ;

use sp_consensus_aura::sr25519::AuthorityId as AuraId;

use pallet_grandpa::AuthorityId as GrandpaId;

use parity_scale_codec::Decode ;










// Pallet config
// -------------------------------------------------

pub trait Config: frame_system::Config   {
	type Event: From<Event<Self>> + Into<<Self as frame_system::Config>::Event>;
}





// Persistent data
// -------------------------------------------------

decl_storage! {
	trait Store for Module<T: Config> as Owners {
		// Total number of authorities registered
		AuthCount: u16 = 0 ;

    	// Registered authorities
    	// 0. Block at which they were registered
    	// 1. Enabled true/false
    	// 2. sr25519 public address
    	// 3. ed25519 public address
    	Authorities: map hasher(identity) T::AccountId => (T::BlockNumber, bool, [u8;32], [u8;32]) ;
	}
	add_extra_genesis {
        config(keys): Vec<([u8;32],[u8;32])>;
        build(|config| Module::<T>::initialize_keys(&config.keys))
    }
}







// Events
// -------------------------------------------------

decl_event!(
	/// Events generated by the module.
	pub enum Event<T>
	where
		AccountId = <T as frame_system::Config>::AccountId,
	{
		AuthorityAdded(AccountId),
    	AuthorityEnabled(AccountId),
    	AuthorityDisabled(AccountId),
	}
);




// Errors
// -------------------------------------------------

decl_error! {
	pub enum Error for Module<T: Config> {

        // 0
        AuthorityAlreadyRegistered,

        // 1
        AuthorityNotRegistered,

        // 2
        InvalidAddress,

	}
}






// Implementation
// -------------------------------------------------

impl<T:Config> AuthorityRegistry<T> for Module<T> {

	fn list_aura() -> Vec<AuraId> {
		let mut ans = vec![] ;
		for (_,(_,_,addr,_)) in Authorities::<T>::iter() {
			let public = sp_core::sr25519::Public::from_raw(addr) ;
			ans.push(public.into()) ;
		}
		ans
	}

    fn list_grandpa() -> Vec<(GrandpaId, u64)> {
		let mut ans = vec![] ;
		for (_,(_,_,_,addr)) in Authorities::<T>::iter() {
			let public = sp_core::ed25519::Public::from_raw(addr) ;
			ans.push((public.into(), 1)) ;
		}
		ans
	}

}



impl<T: Config> Module<T> {

	fn initialize_keys(keys: &Vec<([u8;32],[u8;32])>) {
		let count: u16 = keys.len().try_into().expect("small number") ;
		AuthCount::set(count) ;
		for (sr25519,ed25519) in keys {
			let account: T::AccountId = T::AccountId::decode(&mut &sr25519[..]).expect("valid key") ;
			let zero: u8 = 0 ;
			let block: T::BlockNumber = zero.saturated_into() ;
			Authorities::<T>::insert(&account, (block, true, sr25519, ed25519));
		}
	}

	fn is_registered(who: &T::AccountId) -> bool {
		Authorities::<T>::contains_key(who)
	}

	fn _is_enabled(who: &T::AccountId) -> bool {
		if Authorities::<T>::contains_key(who) {
			Authorities::<T>::get(who).1
		} else {
			false
		}
	}

}


decl_module! {
	pub struct Module<T: Config> for enum Call where origin: T::Origin {

		fn deposit_event() = default;

		// Add an authority
        #[weight = 10_000]
        fn add_authority(origin, account: T::AccountId, addr_sr25519: [u8;32], addr_ed25519: [u8;32]) {
            // Check that the extrinsic is from sudo.
            ensure_root(origin)?;

			// Check that account is not already registered
			ensure!(!Self::is_registered(&account), Error::<T>::AuthorityAlreadyRegistered) ;

			// Add account as a new authority
			let current_block = <frame_system::Module<T>>::block_number();
			let authority = (current_block, true, addr_sr25519, addr_ed25519) ;
			Authorities::<T>::insert(&account, authority);

			// Update total count of authoritiess
			let count = AuthCount::take() + 1 ;
			AuthCount::set(count) ;

            // Emit an event that new validator was added.
            Self::deposit_event(RawEvent::AuthorityAdded(account));
        }

        // Disable an authority
        #[weight = 10_000]
        fn disable_authority(origin, account: T::AccountId) {
            // Check that the extrinsic is from sudo.
            ensure_root(origin)?;

			// Check that account is already registered
			ensure!(Self::is_registered(&account), Error::<T>::AuthorityNotRegistered) ;

			// Disable account
			let mut auth = Authorities::<T>::take(&account) ;
			auth.1 = false ;
			Authorities::<T>::insert(&account, &auth) ;

            // Emit an event that new validator was added.
            Self::deposit_event(RawEvent::AuthorityDisabled(account));
        }

        // Enable an authority
        #[weight = 10_000]
        fn enable_authority(origin, account: T::AccountId) {
            // Check that the extrinsic is from sudo.
            ensure_root(origin)?;

			// Check that account is already in the list
			ensure!(Self::is_registered(&account), Error::<T>::AuthorityNotRegistered) ;

			// Enable account
			let mut auth = Authorities::<T>::take(&account) ;
			auth.1 = true ;
			Authorities::<T>::insert(&account, &auth) ;

            // Emit an event that verifier was enabled.
            Self::deposit_event(RawEvent::AuthorityEnabled(account));
        }

	}

}

